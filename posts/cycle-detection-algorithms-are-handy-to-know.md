-title=Cycle detection algorithms are handy to know
-time=2010-10-08 08:38:26
What the title says :\). Just thought it was worth mentioning since I talked a bit about singly\-linked lists in the ["Data structures and invariants"](*data-structures-and-invariants) post, and cycles are the primary way that a singly\-linked list can "go wrong" on you without containing invalid pointers: notably, you can get this if you try to insert some item `x` to a list when that list already contains `x`. \(If you insert the "new" `x` before or at the position of the `x` that's already in the list, you will get a cycle. If you insert it later, you will inadvertently remove all items between the old and new position\).

When debugging this, it's useful to have some cycle\-detection code. You can add some fields to the list for debugging \(not quite as trivial as it sounds, since clearing a "visited" flag involves traversing the list that might have a cycle \- you need to make sure all fields are in a known "visited" state *before* you start looking for cycles if you do it this way\), but a nicer solution that doesn't require extra memory is to use a cycle detection algorithm. There are two main choices \- Floyd's "tortoise and hare" algorithm and Brent's algorithm \- and both are worth knowing about. They're also explained well on [Wikipedia](http://en.wikipedia.org/wiki/Cycle_detection), so read up if you've never encountered them before.